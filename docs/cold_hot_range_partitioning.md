Cold/Hot Range Partitioning
===

## モチベーション

* 現状、各DPUには1つずつ木を作っている
  * それぞれがキー空間中の連続領域を担っている
* 一部の木に急にhotに (クエリがたくさん来るように) なったとき、負荷を均等にするためにはたくさんのKVペアを動かさなければならない
  * 例えばDPU\#0の木がhotになったら、そこのKVペアを一部DPU\#1へ移動し、DPU\#1からもDPU\#2へ移動し…と玉突きが発生する

<details>
<summary>没にしたモチベーション</summary>

* hotな領域がそこそこに大きく存在すると、**計算の分散とメモリ負荷の分散が両立できなくなる**
  * 計算を均等に分散しようと、hotな領域は小さな区間に分けてDPUに担わせるとする
    * そこに含まれるKVペアも少なくなりうる
  * 一方でcoldな領域は、大きな区間をDPUに担わせる
    * こちらはKVペアをたくさん持つことに
  * 結果として、coldな領域を担うDPUがそのメモリ容量いっぱいの木を持っているとき、hotな領域のDPUはメモリがスカスカである

</details>

## アイデア

* 奥田君がやっていたように、各DPUに2つ以上の木を持たせる
  * しかしあまり木の数を増やすと、ホストでのクエリのroutingの負荷が増える
    * 全体(ホスト+たくさんのDPU)で1つの探索木を構成していると考えると、ホストが担う「上側」の段数が増えている
  * では、各DPUに木は最大2つ、でどうだろうか
    * **hotになった木のKVペアを細かく分けて、もう1つ目の木として全DPUで分担して持つ**
    * これらの木をhot tree(s)、元々の木をcold tree(s)と呼ぶ

## On Heating (考え中)

cold treeがhotになったとき

* ホスト側でのクエリ分配時に検出する
* 指令送信フェーズ
  * heating treeの元へはクエリを送らず、代わりに「serializeしろ」という指令を送る
  * 他の木へは、いつも通りクエリを送る
* 実行フェーズ
  * クエリが来た木では、クエリを処理し、結果配列を作る
  * serialize命令が来た木では、キー配列とバリュー配列を作る
  * CPUでは、heating treeへのクエリをソートする
    * (次のクエリバッチの分配もする)
      * heating treeのキー範囲をどう分割するかを示し合わせることで、分配を計算できる **←本当に？**
* 成果受信フェーズ
  * 結果配列とキー/バリュー配列を読み出す
  * キー/バリュー配列とcold treeからの結果配列をMRAM中の同じ位置 (共用体) に作ることで、効率的に読み出す
* 追加実行フェーズ
  * heating treeのキー/バリュー配列と、ソート済みのクエリを用いて、CPUでクエリを処理する
* 移動フェーズ
  * heating treeのキー/バリュー配列を分割し、hot treeとして分配

## どこを Hot Tree とするのか

### Cold Tree が連続範囲を担うとしたら

* 問題設定
  * cold treeについては要素数とクエリ数の上限がある
    * 要素数の上限を $`E_{c}`$ 、クエリ数の上限を $`Q_{c}`$
  * hot treeについては要素数の上限 $`E_h`$ がある
  * KVペアをソートして連番をふった時、i番目に来るクエリ数の期待値を $`q_i`$ とする
  * 目的関数はhot treeに行くクエリの最大値としたいが、代わりにhot treeに行くクエリの総数とし、これを最小化
* 動的計画法
  * ソートされたKVペアの先頭n個までを、cold treeをc個使って分割したときの、hot treeに行くクエリ数の最小値を $`f(n, c)`$ とする
  * $$
    f(n, c) = \min \left\{\begin{align*}
      & f(n-1, c) + q_{n-1} \quad (\text{hot treeに1要素入れる}) \\
      & \min_{k \in S} f(n - k, c - 1) \ \text{where}\ S = \left\{k \mathrel{}\middle|\mathrel{} \sum_{i=n-k}^{n-1} q_i \leq Q_c \right\} \quad (\text{k要素のcold treeを作る}) \\
    \end{align*}\right.
    $$


